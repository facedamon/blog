---
title: "[标准库 | 输入输出]"
date: 2020-01-16T17:02:56+08:00
#lastmod: 2019-08-30T01:37:56+08:00
toc: true
draft: false
tags: ["golang"]
categories: ["golang/标准库"]
author: "facedamon"
---

> 转载自https://books.studygolang.com/The-Golang-Standard-Library-by-Example/


## 1.1 io--基本的IO接口
&emsp;&emsp;io包为I/O原语提供了基本的接口。它主要包装了这些原语的已有实现。由于这些被接口包装的I/O原语是由不同的低级操作实现，因此，在另外声明之前不该假定它们的并行执行是安全的。

&emsp;&emsp;在io包中最重要的是两个接口：**Reader**和**Writer**接口。本章所提到的各种IO包，都跟这两个接口有关，也就是说，只要满足这两个接口，它就可以使用IO包的功能。


## 1.2 Reader接口
&emsp;&emsp;Reader接口定义如下：
```
Type Reader interface {
    Read(p []byte)(n int, err error)
}
```
&emsp;&emsp;官方文档中关于接口方法的说明：

> &emsp;&emsp;Read将len(p)个字节读取到p中。它返回读取的字节数n(0<=n<=len(p))以及任何遇到的错误。即使Read返回的n<=len(p),它也会在调用过程中占用len(p)个字节作为暂存空间.若可读取的数据不到len(p)个字节，Read会返回可用数据，而不是等待更多数据。
<br>&emsp;&emsp;当Read在成功读取n > 0个字节后遇到一个错误或EOF，它会返回读取的字节数。它可能会同时在本次的调用中返回一个non-nil错误，或在下一次的调用中返回这个错误(且n为0)。一般情况下，Reader会返回一个非0字节数n，若n = len(p)个字节从输入源的结尾处由Read返回，Read可能返回err == EOF或者err == nil.并且之后的Read都应该返回(n:0,err:EOF).
<br>&emsp;&emsp;调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的I/O错误，同时允许EOF的出现。

&emsp;&emsp;根据Go语言中关于接口和满足了接口的类型定义，我们知道Reader接口的方法集只包含一个Read方法，因此，所有实现了Read方法的类型都满足io.Reader接口，也就是说，在所有需要io.Reader的地方，可以传递实现了Read方法的类型的实例.

&emsp;&emsp;下面，我们通过具体例子来谈谈该接口的用法。

```
func ReadFrom(reader io.Reader, num int) ([]byte, error) {
    p := make([]byte, num)
    n, err := reader.Read(p)
    if n > 0 {
        return p[:n], nil
    }
    return p, err
}
```

&emsp;&emsp;ReadForm函数将io.Reader作为参数，也就是说, ReadFrom可以从任意的地方读取数据，只要来源实现了io.Reader接口。比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：

```
// 从标准输入读取
data, err = ReadFrom(os.Stdin, 11)

// 从普通文件读取,其中file是os.File的实例
data, err = ReadFrom(file, 9)

// 从字符串读取
data, err = ReadFrom(strings.NewReader("from string"), 12)
```

- io.EOF变量的定义：var EOF = errors.New("EOF"),是error类型。根据reader接口的说明，在n > 0且数据被读完了的情况下，当次返回的error有可能是EOF也有可能是nil


## 1.3 Writer接口
&emsp;&emsp;接口定义如下：
```
type Writer interface {
    Write(p []byte) (n int, err error)
}
```
&emsp;&emsp;官方文档中关于该接口方法的说明:

> Write将len(p)个字节从p中写入到基本数据流中。它返回从p中被写入的字节数n