<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on FaceDamon`s Blog</title>
    <link>http://facedamon.github.io/post/</link>
    <description>Recent content in Posts on FaceDamon`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 28 Jul 2020 16:26:56 +0800</lastBuildDate>
    
	<atom:link href="http://facedamon.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[树形结构 | 前缀树(敏感词过滤)]</title>
      <link>http://facedamon.github.io/post/data-struct/tree-struct/trie/</link>
      <pubDate>Tue, 28 Jul 2020 16:26:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/tree-struct/trie/</guid>
      <description>摘要 前缀树，又称字典树。之前在手写http框架(路由)中已经略有介绍。这次我们专门做一个关于前缀树的详细介绍及应用。 前缀树主要应用于统计，排</description>
    </item>
    
    <item>
      <title>[分布式缓存 (三) | HTTP]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-http/</link>
      <pubDate>Fri, 24 Jul 2020 16:58:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-http/</guid>
      <description>摘要 分布式缓存需要实现节点间通信，建立基于HTTP的通信机制是比较常见的做法。如果一个节点启动了HTTP服务， 那么这个节点就可以被其它节点访</description>
    </item>
    
    <item>
      <title>[分布式缓存 (二) | 确保一致性]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rwmutex/</link>
      <pubDate>Mon, 20 Jul 2020 15:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rwmutex/</guid>
      <description>摘要 在上一篇博客中，我们实现了LRU缓存淘汰策略。接下来我们使用sync.RWMutex封装LRU的几个方法，使之支持并发的读写。(对于并发</description>
    </item>
    
    <item>
      <title>[分布式缓存 (一) | LRU 淘汰策略]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-lru/</link>
      <pubDate>Mon, 20 Jul 2020 10:32:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-lru/</guid>
      <description>淘汰算法简介 geec的缓存全部存储在内存中，内存是有限的，因此不可能无限制添加数据。假定，我们设置缓存能够使用的内存大小为N,那么在某一个时</description>
    </item>
    
    <item>
      <title>[谈谈分布式缓存 (零) | golang cache]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E8%B0%88%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</link>
      <pubDate>Mon, 20 Jul 2020 09:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E8%B0%88%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</guid>
      <description>摘要 第一次请求时将一些耗时操作的结果暂存，以后遇到相同的请求，直接返回暂存的数据。我想这是大部分人对于缓存的理解。在计算机系统中，缓存无处不</description>
    </item>
    
    <item>
      <title>[手写http框架 (六) | golang recover]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-recover/</link>
      <pubDate>Fri, 17 Jul 2020 09:22:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-recover/</guid>
      <description>摘要 在go中，比较常见的错误处理方式是返回error，由调用者巨顶后续如何处理。但是如果是无法恢复的错误，可以手动触发panic，当然如果在</description>
    </item>
    
    <item>
      <title>[手写http框架 (五) | golang middleware]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-middleware/</link>
      <pubDate>Thu, 16 Jul 2020 10:30:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-middleware/</guid>
      <description>摘要 中间件(middleware)，简单的说，就是非业务的技术类组件。http框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此</description>
    </item>
    
    <item>
      <title>[手写http框架 (四) | golang group]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-group/</link>
      <pubDate>Thu, 16 Jul 2020 09:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-group/</guid>
      <description>摘要 分组控制是http框架提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景</description>
    </item>
    
    <item>
      <title>[手写http框架 (三) | golang router]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-router/</link>
      <pubDate>Tue, 14 Jul 2020 16:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-router/</guid>
      <description>摘要 使用trie树实现动态路由解析 支持两种模式:name和*filepath trie树 上一节，我们用了一个非常简单的map结果来存储了路由表</description>
    </item>
    
    <item>
      <title>[系统监控 | Prometheus (二)]</title>
      <link>http://facedamon.github.io/post/promethues/prometheus%E4%BA%8C/</link>
      <pubDate>Fri, 03 Jul 2020 15:43:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/promethues/prometheus%E4%BA%8C/</guid>
      <description>参见 https://yunlzheng.gitbook.io/prometheus-book/</description>
    </item>
    
    <item>
      <title>[系统监控 | Prometheus (一)]</title>
      <link>http://facedamon.github.io/post/promethues/prometheus%E4%B8%80/</link>
      <pubDate>Fri, 03 Jul 2020 11:03:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/promethues/prometheus%E4%B8%80/</guid>
      <description>摘要 由于该系统涉及较多的概念和技术，为了快速上手，第一篇文档主要讲解环境搭建。后期系列文档会逐一解释每一个关键的结点。 系统架构 简略解释 Pro</description>
    </item>
    
    <item>
      <title>[手写http框架 (二) | golang context]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-context/</link>
      <pubDate>Wed, 24 Jun 2020 11:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-context/</guid>
      <description>摘要 将路由router独立出来，方便之后增强。 设计上下文context，封装Request和Response，提供对JSON、HTML等返回</description>
    </item>
    
    <item>
      <title>[手写http框架 (一) | golang http-handler]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-httphandler/</link>
      <pubDate>Tue, 23 Jun 2020 15:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-httphandler/</guid>
      <description>摘要 简单介绍net/http库以及http.Handler接口 搭建Gee框架的雏形 标准库启动Web服务 Go语言内置了net/http库，封装</description>
    </item>
    
    <item>
      <title>[HTTP | golang net/http 源码解读]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-http%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 20 Jun 2020 10:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-http%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>重要接口 接口名称 简略含义 Handler 处理请求接口 ResponseWriter 返回响应接口 ServeMux 路由 Conn tcp连接 Handler type Handler interface { ServeHTTP(ResponseWriter, *Request) } Handler接口是一个逻辑接口，所有的请求都会进入该</description>
    </item>
    
    <item>
      <title>[mongodb (一) | 基本操作]</title>
      <link>http://facedamon.github.io/post/mongodb/1.-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 09 Jun 2020 09:09:42 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/mongodb/1.-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <description>基本操作 创建document #use dbname use chapter; 删除document #db.dropDatabase() use chapter; db.dropDatabase() 创建collection #db.createCollection(name, options) # example 集合空间大小614299KB,文档最大个数为</description>
    </item>
    
    <item>
      <title>[工程师学习方法]</title>
      <link>http://facedamon.github.io/post/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 02 Jun 2020 14:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</guid>
      <description>环境 一名工程师在萌芽之中，特别容易自我劝退，偏安一隅。他们有一点解决自己温饱的技术，有一份较为稳定的工作，但他们态度恶劣，从来不学习如何学习</description>
    </item>
    
    <item>
      <title>[杂谈 | golang接口型函数]</title>
      <link>http://facedamon.github.io/post/golang/golang%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 22 May 2020 09:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/</guid>
      <description>转载自 https://www.flysnow.org/2016/12/30/golang-function-interface.html 简介 接口型函数，指的是用函数实现接口，这样在调用的时候就会非常简便，这种方式使用于只有一个函数的接口。 原始接口 我们以迭代一个map为</description>
    </item>
    
    <item>
      <title>[杂谈 | golang database/sql使用]</title>
      <link>http://facedamon.github.io/post/golang/golang-database/sql%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 11 May 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang-database/sql%E4%BD%BF%E7%94%A8/</guid>
      <description>转载自 https://segmentfault.com/a/1190000003036452 概述 sql.DB不是一个连接，它是数据库的抽象接口。它可以根据driver打开关闭数据库连接，管理连接池。正在使用的连接被标记为繁忙</description>
    </item>
    
    <item>
      <title>[生活 | 旅游 | 川西小环线]</title>
      <link>http://facedamon.github.io/post/life/travel/2.%E5%B7%9D%E8%A5%BF%E5%B0%8F%E7%8E%AF%E7%BA%BF/</link>
      <pubDate>Fri, 01 May 2020 14:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/life/travel/2.%E5%B7%9D%E8%A5%BF%E5%B0%8F%E7%8E%AF%E7%BA%BF/</guid>
      <description>前言 **2019年国庆是一个值得纪念的日子。**这是我第一次长途旅行，这次我放弃了贴吧寻找驴友，上面人多眼杂。几经转折后，相中了8264户外</description>
    </item>
    
    <item>
      <title>[Git (四) | 分支管理(案例驱动)]</title>
      <link>http://facedamon.github.io/post/git/4.-git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 30 Apr 2020 09:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/4.-git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</guid>
      <description>摘要 案例，实际工作中你会用到类似的流程。 开发某个网站 为实现某个新的需求，创建分支 在该分支上开展工作 正在此时，你接到通知，有一个很严重的bug</description>
    </item>
    
    <item>
      <title>[Git (三) | 分支原理]</title>
      <link>http://facedamon.github.io/post/git/3.-git%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 29 Apr 2020 16:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/3.-git%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86/</guid>
      <description>摘要 之所以要将Git分支原理单独讲解，主要是想好好理解一下Git的分支模型，这对以后的分支管理学习大有裨益。 简介 为了真正理解Git处理分支的</description>
    </item>
    
    <item>
      <title>[Git (二) | 上手]</title>
      <link>http://facedamon.github.io/post/git/2.-git%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Mon, 27 Apr 2020 10:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/2.-git%E4%B8%8A%E6%89%8B/</guid>
      <description>概要 希望通过这一节学习，能够快速掌握配置初始化仓库(repository)、开始或停止跟踪(track)文件、暂存(stage)、提交(co</description>
    </item>
    
    <item>
      <title>[Git (一) | 三种状态和基础配置]</title>
      <link>http://facedamon.github.io/post/git/1.-git%E7%8A%B6%E6%80%81%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 27 Apr 2020 09:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/1.-git%E7%8A%B6%E6%80%81%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</guid>
      <description>三种状态 Git有三种状态：已提交(committed), 已修改(modified), 已暂存(staged)。已提交表示数据已经安全的保存在本</description>
    </item>
    
    <item>
      <title>[生活 | 旅游 | 牛背山]</title>
      <link>http://facedamon.github.io/post/life/travel/1.%E7%89%9B%E8%83%8C%E5%B1%B1/</link>
      <pubDate>Sat, 25 Apr 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/life/travel/1.%E7%89%9B%E8%83%8C%E5%B1%B1/</guid>
      <description>四川牛背山之旅 前言 依稀记得，在2019年元旦时，初来成都，除了工作上的同事，自己没有几个耍得来的要好朋友。一次偶然的机会，在冲浪成都豆瓣时，</description>
    </item>
    
    <item>
      <title>[nginx (一) | nginx准备]</title>
      <link>http://facedamon.github.io/post/nginx/1.nginx%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 16 Apr 2020 14:23:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/nginx/1.nginx%E5%9F%BA%E7%A1%80/</guid>
      <description>准备环境 首先需要一个内核为Linux 2.6及以上版本的操作系统，因为Linux 2.6及以上内核才支持epoll。在linux上使用selec</description>
    </item>
    
    <item>
      <title>[微服务设计(二) | 如何建模服务]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/2.-%E5%A6%82%E4%BD%95%E5%BB%BA%E6%A8%A1%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 13 Apr 2020 09:55:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/2.-%E5%A6%82%E4%BD%95%E5%BB%BA%E6%A8%A1%E6%9C%8D%E5%8A%A1/</guid>
      <description>摘要 同过上节的讨论，我们已经知道什么是微服务了，你可能已经迫不及待地想要实现它了。但是从何做起呢？在本节中，我们会讨论如何确定服务之间的边界</description>
    </item>
    
    <item>
      <title>[微服务设计(一) | 微服务]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/1.-%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sun, 12 Apr 2020 13:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/1.-%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <description>摘要 随着领域驱动设计、持续交付、按需虚拟化、基础设施自动化、小型自治团队、大型集群系统、模块化的流行，微服务也应运而生。它并不是被发明出来的</description>
    </item>
    
    <item>
      <title>[golang base(十一) | 分布式网络爬虫]</title>
      <link>http://facedamon.github.io/post/golang/base/11.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</link>
      <pubDate>Fri, 06 Mar 2020 17:08:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/11.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</guid>
      <description>原因 有一定的复杂性 可以灵活调整项目的复杂性 平衡语言/爬虫之间的比重 爬虫分类 通用爬虫，如baidu，google 聚焦爬虫，从互联网获取结构化数</description>
    </item>
    
    <item>
      <title>[golang base(十) | 广度优先搜索]</title>
      <link>http://facedamon.github.io/post/golang/base/10.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Thu, 05 Mar 2020 15:29:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/10.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</guid>
      <description>广度优先算法 为爬虫实战做好准备 应用广泛，综合性强 面试常见 上图中是一个6*5的迷宫，0 代表可以走，1 代表墙，从左上角进右下角出，只能上左下右，</description>
    </item>
    
    <item>
      <title>[golang base(九) | 标准库]</title>
      <link>http://facedamon.github.io/post/golang/base/9.http%E6%A0%87%E5%87%86%E5%BA%93/</link>
      <pubDate>Thu, 05 Mar 2020 14:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/9.http%E6%A0%87%E5%87%86%E5%BA%93/</guid>
      <description>http 使用http客户端发送请求 使用http.Client控制请求头部等 使用httputil简化工作 package main func main(){ // 访问手机版imooc r, err := http.NewRequest(http.MethodGet, &amp;quot;http://www.imooc.com&amp;quot;, nil) r.Header.Add(&amp;quot;User-Agent&amp;quot;,</description>
    </item>
    
    <item>
      <title>[golang base(八) | 再谈channel]</title>
      <link>http://facedamon.github.io/post/golang/base/8.channel/</link>
      <pubDate>Wed, 04 Mar 2020 20:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/8.channel/</guid>
      <description>转载自 https://www.cnblogs.com/sparkdev/ 转载自 https://go-zh.org/ref/mem golang官网内存模型分析 转载自 https://taohuawu.club/high-performance-implementation-of-goroutine-pool 忠告 程序在修改被多个Go程同时访问的数据时必须序列化该访问。要序列化访问，需要通过Cha</description>
    </item>
    
    <item>
      <title>[golang base(八) | goroutine &amp; channel]</title>
      <link>http://facedamon.github.io/post/golang/base/8.-goroutine/</link>
      <pubDate>Wed, 04 Mar 2020 20:00:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/8.-goroutine/</guid>
      <description>goroutine package main func main() { for i := 0; i &amp;lt; 10; i++ { go func(i int){ for { fmt.Printf(&amp;quot;Hello from goroutine %d\n&amp;quot;, i) } }(i) } time.Sleep(time.Millisecond) } 如果不加go关键字的话，就是外循环进来一次一直执行匿名函数，不会退出。加了go关</description>
    </item>
    
    <item>
      <title>[golang base(七) | 测试与性能调优]</title>
      <link>http://facedamon.github.io/post/golang/base/7.%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</link>
      <pubDate>Sun, 01 Mar 2020 13:05:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/7.%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</guid>
      <description>Debugging Sucks and Testing Rocks 测试 传统测试 VS 表格驱动测试 传统测试 @Test public void testAdd() { assertEquals(3, add(1, 2)); assertEquals(Integer.MIN_VALUE, add(1, Integer.MAX_VALUE)); } 测试数据和测试逻辑混在一起 出错信息不明确 一旦一个数据出错测试全部结束 表格</description>
    </item>
    
    <item>
      <title>[golang base(六) | 错误处理]</title>
      <link>http://facedamon.github.io/post/golang/base/6.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 28 Feb 2020 17:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/6.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>资源管理与出错处理 defer调用 确保在函数结束时调用 package main func tryDefer() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) panic(&amp;quot;error occurr&amp;quot;) //触发return fmt.Println(4) } func writeFile(filename string) { file, err := os.OpenFile(filename, os.O_EXCL|os.O_CREATE, 0666) if err != nil { panic(err) } defer file.Close() writer</description>
    </item>
    
    <item>
      <title>[golang base(五) | 函数式编程]</title>
      <link>http://facedamon.github.io/post/golang/base/5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 28 Feb 2020 17:36:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>函数式编程 函数式编程 VS 函数指针 函数是一等公民：参数，变量，返回值都可以是函数 闭包 package main func adder() func(int) int { sum := 0 // 自由变量 return func (v int) int { sum += v //v 局部变量 return</description>
    </item>
    
    <item>
      <title>[golang base(四) | 面向接口]</title>
      <link>http://facedamon.github.io/post/golang/base/4.%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Fri, 28 Feb 2020 17:23:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/4.%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</guid>
      <description>接口 duck typing 大黄鸭是不是一个鸭子? 传统类型系统：脊索动物，脊椎动物亚门，鸟纲雁形目。。。:no duck typing :yes，像鸭子走路，像鸭子叫，那么就是鸭子 描</description>
    </item>
    
    <item>
      <title>[golang base(三) | 面向对象]</title>
      <link>http://facedamon.github.io/post/golang/base/3.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 28 Feb 2020 17:07:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/3.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>结构体和方法 golang仅支持封装，不支持继承和多态 golang没有class，只有struct golang结构体没有构造方法这一说法 type treeNode struct</description>
    </item>
    
    <item>
      <title>[golang base(二) | 内建容器]</title>
      <link>http://facedamon.github.io/post/golang/base/2.%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Fri, 28 Feb 2020 15:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/2.%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/</guid>
      <description>数组 数量写在类型的前面 func main() { // var 需要确定大小，可以不用初始化赋值 var arr1 [5]int // 简化，需要确定大小，需要初始化赋值 arr2 := [3]int{1, 3, 5} // ... 编译器根据初始化赋值</description>
    </item>
    
    <item>
      <title>[golang base(一) | 基础语法]</title>
      <link>http://facedamon.github.io/post/golang/base/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 28 Feb 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>变量定义 在golang中变量名在前变量类型在后 这样设计的初衷是什么?我们回想一下使用其它语言的变量的时候是先想到变量的名字还是先想到变量类型</description>
    </item>
    
    <item>
      <title>[杂谈 | golang设计哲学 ]</title>
      <link>http://facedamon.github.io/post/golang/golang%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</link>
      <pubDate>Thu, 02 Jan 2020 14:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</guid>
      <description>世界是并行的 先不说宇宙，就整个地球来说，世界万物都是并行发生的；天生对并发支持良好的go语言更容易描述并行的世界。 #世界是由物质组合构成的 微</description>
    </item>
    
    <item>
      <title>[杂谈 | golang发现序列]</title>
      <link>http://facedamon.github.io/post/golang/golang%E5%8F%91%E7%8E%B0%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 02 Jan 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E5%8F%91%E7%8E%B0%E5%BA%8F%E5%88%97/</guid>
      <description>发现了一个好用的golang sql package sqlx，有点类似与java中的dbutils，可以实现结果集的自动映射 sqlx它没有传统ORM的繁琐，毕竟</description>
    </item>
    
    <item>
      <title>[杂谈 | golang是值传递 ]</title>
      <link>http://facedamon.github.io/post/golang/golang%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</link>
      <pubDate>Thu, 02 Jan 2020 12:36:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</guid>
      <description>什么是值传递 值传递的意思是：函数传递总是原来这个东西的一个副本，一幅拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；</description>
    </item>
    
    <item>
      <title>[树形结构 | 二叉查找树]</title>
      <link>http://facedamon.github.io/post/data-struct/tree-struct/bstree/</link>
      <pubDate>Thu, 07 Nov 2019 17:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/tree-struct/bstree/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 转载《算法导论》 转载 https://github.com/emirpasic/gods 概要 本节先对二叉树的相关理论知识进行介绍，然后给出Java的详细实现。关于二叉树的学习，需要说明的是：它并不难</description>
    </item>
    
    <item>
      <title>[线性结构 | 队列]</title>
      <link>http://facedamon.github.io/post/data-struct/linear-struct/%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 05 Nov 2019 17:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/linear-struct/%E9%98%9F%E5%88%97/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 概要 本节介绍队列的基本原理，然后分别给出队列的Java、Golang两种语言的实现。 队列的介绍 队列是一种线性存储结构。它有以下特点：</description>
    </item>
    
    <item>
      <title>[线性结构 | 栈 ]</title>
      <link>http://facedamon.github.io/post/data-struct/linear-struct/%E6%A0%88/</link>
      <pubDate>Tue, 05 Nov 2019 10:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/linear-struct/%E6%A0%88/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 概要 本节会现对栈的原理进行介绍，然后分别通过Java/Golang三种语言来演示栈的实现示例。 栈的介绍 栈是一种线性存储结构，它有以下</description>
    </item>
    
    <item>
      <title>[线性结构 | 数组、单链表、双向链表]</title>
      <link>http://facedamon.github.io/post/data-struct/linear-struct/%E6%95%B0%E7%BB%84-%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 24 Oct 2019 15:31:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/linear-struct/%E6%95%B0%E7%BB%84-%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 概要 线性表是一种线性结构，它是具有相同类型的n(n&amp;gt;=0)个元素的有序序列。本节介绍线性表的几个基本组成部分：数组、单向链表、</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 装饰模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/wrapper/</link>
      <pubDate>Thu, 24 Oct 2019 14:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/wrapper/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 装饰模式又名包装(Wrapper)模式.装饰模式以对客户端透</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 享元模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/flyweight/</link>
      <pubDate>Thu, 24 Oct 2019 14:34:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/flyweight/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 主要用于减少创建对象的数量,以减少内存占用和提高性能,它提供</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 桥梁模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/bridge/</link>
      <pubDate>Thu, 24 Oct 2019 11:11:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/bridge/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 桥梁模式是对象的结构模式。又称为柄体(Handle and Body</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 门面模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/facade/</link>
      <pubDate>Thu, 24 Oct 2019 10:59:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/facade/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 外观模式,隐藏系统的复杂性,并向客户端提供了一个客户端可以访</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 适配器模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/adapter/</link>
      <pubDate>Wed, 16 Oct 2019 15:03:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/adapter/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 适配器模式把一个类的接口变换成客户端所期待的另一种接口,从而</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 合成模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/composite/</link>
      <pubDate>Wed, 16 Oct 2019 09:46:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/composite/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 合成模式属于对象的结构模式,有时又叫做&amp;rsquo;部分-整</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 代理模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/proxy/</link>
      <pubDate>Tue, 15 Oct 2019 19:06:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/proxy/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 定义 创建具有现有对象的对象，以便向外界提供功能接口 目的 为其他</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 原型模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/prototype/</link>
      <pubDate>Tue, 15 Oct 2019 17:22:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/prototype/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 通过给出一个原型对象来知名所有创建的对象的类型，然后用复制这</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 构建模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/builder/</link>
      <pubDate>Tue, 15 Oct 2019 17:06:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/builder/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 建造模式是对象的创建模式。建造模式可以将一个产品的内部表象(</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 抽象工厂模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/abstract-factory/</link>
      <pubDate>Tue, 15 Oct 2019 15:43:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/abstract-factory/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 概述 举个生活中常见的例子&amp;ndash;组装电脑。 我们在组装电</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 动态工厂模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/dynamic-factory/</link>
      <pubDate>Tue, 15 Oct 2019 15:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/dynamic-factory/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 工厂方法模式是类的创建模式，又叫多态性工厂模式，他的用意是定</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 静态工厂模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/static-factory/</link>
      <pubDate>Tue, 15 Oct 2019 15:36:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/static-factory/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 简单工厂模式是类的创建型模式，又叫静态工厂方法模式。简单工厂</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 单例模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/singleton/</link>
      <pubDate>Tue, 15 Oct 2019 15:10:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/singleton/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 单例类只能有一个实例 单例类必须自己创建自己的唯一实例 单例类必</description>
    </item>
    
    <item>
      <title>[设计模式 | 行为模式 | 模板模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/behavior-type/templates/</link>
      <pubDate>Tue, 15 Oct 2019 14:59:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/behavior-type/templates/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 概述 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形</description>
    </item>
    
    <item>
      <title>[设计模式 | 行为模式 | 解释器模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/behavior-type/interpreter/</link>
      <pubDate>Tue, 15 Oct 2019 14:28:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/behavior-type/interpreter/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 概述 给定一个语言后,解释器模式可以定义出其文法的一种表示,并</description>
    </item>
    
    <item>
      <title>[设计模式 | 行为模式 |观察者模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/behavior-type/observer/</link>
      <pubDate>Tue, 15 Oct 2019 11:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/behavior-type/observer/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 概述 观察者模式是对象的行为模式，又叫发布-订阅(Publis</description>
    </item>
    
    <item>
      <title>[设计模式 | 行为模式 | 迭代器模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/behavior-type/lterator/</link>
      <pubDate>Tue, 15 Oct 2019 11:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/behavior-type/lterator/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[设计模式 | 行为模式 | 策略模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/behavior-type/strategy/</link>
      <pubDate>Tue, 15 Oct 2019 10:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/behavior-type/strategy/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 概述 策略模式属于对象的行为模式。其用意是针对一组算法，将每一</description>
    </item>
    
    <item>
      <title>[大型网站技术架构 | 架构模式]</title>
      <link>http://facedamon.github.io/post/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/1.-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 15 Oct 2019 10:13:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/1.-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid>
      <description>概述 为了解决大型网站面临的高并发访问、海量数据处理、高可靠运行等一系列问题和挑战，大型互联网概述在实践中提出了许多解决方案，以实现网站高性能</description>
    </item>
    
    <item>
      <title>[实战笔记(二十二) | Go unsafe内存布局]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C-go-unsafe%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link>
      <pubDate>Mon, 14 Oct 2019 02:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C-go-unsafe%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid>
      <description>转载自 https://www.flysnow.org 简介 unsafe，顾名思义，是不安全的，Go定义这个包名也是这个意思，让我们尽可能不要使用它，如果你使用它，看到了这个名字，也会想到</description>
    </item>
    
    <item>
      <title>[实战笔记(二十一) | Go Struct Tag]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80-go-struct-tag/</link>
      <pubDate>Mon, 14 Oct 2019 02:00:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80-go-struct-tag/</guid>
      <description>转载自 https://www.flysnow.org JSON字符串对象转换 type User struct{ Name string `name` Age int `age` } func main(){ var u User h := `{&amp;quot;name&amp;quot;: &amp;quot;张三&amp;quot;, &amp;quot;age&amp;quot;:15}` err := json.Unmarshall([]byte(h), &amp;amp;u) if err != nil { fmt.Println(err) }else{ fmt.Println(u) } } 上面的例子就是</description>
    </item>
    
    <item>
      <title>[实战笔记(二十) | Go 反射]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81-go-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Mon, 14 Oct 2019 01:59:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81-go-%E5%8F%8D%E5%B0%84/</guid>
      <description>转载自 https://www.flysnow.org 介绍 和java语言一样，Go也实现运行时反射，这为我们提供一种可以在运行时操作任意类型对象的能力。比如我们可以查看一个接口类型变量的</description>
    </item>
    
    <item>
      <title>[实战笔记(十九) | Go 基准测试]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B9%9D-go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:58:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B9%9D-go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</guid>
      <description>转载自 https://www.flysnow.org 什么是基准测试 基准测试，是一种测试代码性能的方法，比如你有多种不同的方案，都可以解决问题，那么到底那种方案性能更好呢？这个时候基准测</description>
    </item>
    
    <item>
      <title>[实战笔记(十八) | Go 单元测试]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:57:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>转载自 https://www.flysnow.org 什么是单元测试 单元测试一般是用来测试我们的代码逻辑有没有问题，有没有按照我们期望的运行，以保证代码质量。 大多数的单元测试，都是对某一</description>
    </item>
    
    <item>
      <title>[实战笔记(十七) | Go Context]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83-go-context/</link>
      <pubDate>Mon, 14 Oct 2019 01:56:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83-go-context/</guid>
      <description>转载自 https://www.flysnow.org 前言 控制并发有两种经典的方式，一种是WaitGroup，另外一种就是Context，今天我就谈谈Context。 什么是WaitGro</description>
    </item>
    
    <item>
      <title>[实战笔记(十六) | Go Writer Reader]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD-go-writer-reader/</link>
      <pubDate>Mon, 14 Oct 2019 01:55:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD-go-writer-reader/</guid>
      <description>转载自 https://www.flysnow.org 输入输出 Go Writer和Reader接口的设计遵循Unix的输入输出，一个程序的输出可以是两个一个程序的输入。它们的功能单一并且纯粹</description>
    </item>
    
    <item>
      <title>[实战笔记(十五) | Go 日志]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94-go-%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 14 Oct 2019 01:54:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94-go-%E6%97%A5%E5%BF%97/</guid>
      <description>转载自 https://www.flysnow.org 日志使用 日志分析，就是根据输出的日志信息，分析挖掘可能的问题，我们使用fmt.Println系列函数也可以达到目的，因为它们也可以把</description>
    </item>
    
    <item>
      <title>[实战笔记(十四) | Go 读写锁]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B-go%E8%AF%BB%E5%86%99%E9%94%81/</link>
      <pubDate>Mon, 14 Oct 2019 01:53:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B-go%E8%AF%BB%E5%86%99%E9%94%81/</guid>
      <description>转载自 https://www.flysnow.org 读写锁 前面的有篇文章在讲资源竞争的时候，讲互斥锁，互斥锁的根本就是当一个goroutine访问的时候，其它goroutine都不能访</description>
    </item>
    
    <item>
      <title>[实战笔记(十三) | Go 并发示例数据库连接池]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Mon, 14 Oct 2019 01:52:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>转载自 https://www.flysnow.org 资源池 这篇文章演示使用有缓冲的通道实现一个资源池，这个资源池可以管理在任意多喝goroutine之间共享的资源，比如网络链接、数据库</description>
    </item>
    
    <item>
      <title>[实战笔记(十二) | Go 并发示例]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B/</guid>
      <description>转载自 https://www.flysnow.org 简介 这篇通过一个例子，演示使用通道来监控程序的执行时间，生命周期，甚至终止程序等等。我们这个程序叫runner，我们可以称之为执行者</description>
    </item>
    
    <item>
      <title>[实战笔记(十一) | Go 通道]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80-go%E9%80%9A%E9%81%93/</link>
      <pubDate>Mon, 14 Oct 2019 01:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80-go%E9%80%9A%E9%81%93/</guid>
      <description>转载自 https://www.flysnow.org 简介 上一篇，我们讲了原子函数和互斥锁，都可以保证共享数据的读写，但是呢，它们还是有点复杂，而且影响性能，对此，go又为我们提供了一种</description>
    </item>
    
    <item>
      <title>[实战笔记(十) | Go 资源竞争]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89/</link>
      <pubDate>Mon, 14 Oct 2019 01:49:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89/</guid>
      <description>转载自 https://www.flysnow.org 概述 有并发，就有资源竞争，如果两个或者多个goroutine在没有相互同步的情况下，访问某个共享的资源，比如同时对该资源进行读写，就</description>
    </item>
    
    <item>
      <title>[实战笔记(九) | Go goroutine]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%9D-go-goroutine/</link>
      <pubDate>Mon, 14 Oct 2019 01:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%9D-go-goroutine/</guid>
      <description>转载自 https://www.flysnow.org 并发和并行 在谈goroutine之前，我们先谈谈并发和并行。 一般的程序，如果没有特殊的要求的话，是顺序执行的，这样的程序也容易编写维</description>
    </item>
    
    <item>
      <title>[实战笔记(八) | Go 标志符可见性]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AB-go%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</link>
      <pubDate>Mon, 14 Oct 2019 01:47:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AB-go%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</guid>
      <description>转载自 https://www.flysnow.org 大小写 go的标志符，这个翻译感觉怪怪的，不过还是按这个起了标题，可以理解为go的变量、类型、字段等。这里的可见性，也就是说那些方法、</description>
    </item>
    
    <item>
      <title>[实战笔记(七) | Go 嵌入类型]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%83-go%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:46:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%83-go%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</guid>
      <description>转载自 https://www.flysnow.org 组合NO继承 敲入类型，这是一种可以把已有的类型声明在新的类型里的一种方式，这种功能对代码复用非常重要。 在其它语言中，有继承可以做同样</description>
    </item>
    
    <item>
      <title>[实战笔记(六) | Go 函数方法]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AD-go%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AD-go%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</guid>
      <description>转载自 https://www.flysnow.org 简介 在Go语言中，函数和方法不太一样，有明确的概念区分。函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接收者的；而方法是</description>
    </item>
    
    <item>
      <title>[实战笔记(五) | Go Map]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%94-go-map/</link>
      <pubDate>Mon, 14 Oct 2019 01:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%94-go-map/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现(关于Hash散列细枝末节详见Java下的散列表) Map是给予散列表来实现的，就是我们常说的Hash表，所以我们每次迭代m</description>
    </item>
    
    <item>
      <title>[实战笔记(四) | Go切片]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B-go%E5%88%87%E7%89%87/</link>
      <pubDate>Mon, 14 Oct 2019 01:43:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B-go%E5%88%87%E7%89%87/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现 切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是</description>
    </item>
    
    <item>
      <title>[实战笔记(三) | Go数组]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%89-go%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 14 Oct 2019 01:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%89-go%E6%95%B0%E7%BB%84/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现 要想更清晰的了解数组，我们得了解它的内部实现。数组是长度固定的数据类型，必须存储一段相同类型的元素，而且这些元素是连续的。</description>
    </item>
    
    <item>
      <title>[实战笔记(二) | Go command]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C-go-command/</link>
      <pubDate>Mon, 14 Oct 2019 01:41:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C-go-command/</guid>
      <description>转载自 https://www.flysnow.org Go开发工具概览 Go is a tool for managing for Go source code. Usage: go command [arguments] The command are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information bug start a bug report fix run go tool fix on packages fmt run gofmt on package sources generate generate</description>
    </item>
    
    <item>
      <title>[实战笔记(一) | 包管理]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 14 Oct 2019 01:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>转载自 https://www.flysnow.org 1. 包的命名 go语言的包的命名，遵循简洁、小写、和go文件所在目录同名的原则，这样便于引用，书写以及快速定位查找。 比如go自带的htt</description>
    </item>
    
    <item>
      <title>[Golang内建类型]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B/</guid>
      <description>Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型 基础类型 聚合类型 引用类型 接口类型 无效类型 数字、字符串、布尔 数组、结构体 指针</description>
    </item>
    
    <item>
      <title>[Golang面试题]</title>
      <link>http://facedamon.github.io/post/golang/interview/golang-1/</link>
      <pubDate>Sat, 12 Oct 2019 01:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/interview/golang-1/</guid>
      <description>此Golang面试题摘自网络，已经找不到作者了，所以使用someone代替。 1. 写出下面代码输出内容 package main import ( &amp;quot;fmt&amp;quot; ) func main() { defer_call() } func defer_call() { defer func() { fmt.</description>
    </item>
    
  </channel>
</rss>