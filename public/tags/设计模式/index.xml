<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on FaceDamon`s Blog</title>
    <link>http://facedamon.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on FaceDamon`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 24 Oct 2019 14:44:56 +0800</lastBuildDate>
    
	<atom:link href="http://facedamon.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[设计模式 | 结构模式 | 装饰模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/wrapper/</link>
      <pubDate>Thu, 24 Oct 2019 14:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/wrapper/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 装饰模式又名包装(Wrapper)模式.装饰模式以对客户端透</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 享元模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/flyweight/</link>
      <pubDate>Thu, 24 Oct 2019 14:34:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/flyweight/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 主要用于减少创建对象的数量,以减少内存占用和提高性能,它提供</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 桥梁模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/bridge/</link>
      <pubDate>Thu, 24 Oct 2019 11:11:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/bridge/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 桥梁模式是对象的结构模式。又称为柄体(Handle and Body</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 门面模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/facade/</link>
      <pubDate>Thu, 24 Oct 2019 10:59:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/facade/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 外观模式,隐藏系统的复杂性,并向客户端提供了一个客户端可以访</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 适配器模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/adapter/</link>
      <pubDate>Wed, 16 Oct 2019 15:03:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/adapter/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 适配器模式把一个类的接口变换成客户端所期待的另一种接口,从而</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 合成模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/composite/</link>
      <pubDate>Wed, 16 Oct 2019 09:46:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/composite/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 合成模式属于对象的结构模式,有时又叫做&amp;rsquo;部分-整</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构模式 | 代理模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/structural-type/proxy/</link>
      <pubDate>Tue, 15 Oct 2019 19:06:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/structural-type/proxy/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 定义 创建具有现有对象的对象，以便向外界提供功能接口 目的 为其他</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 原型模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/prototype/</link>
      <pubDate>Tue, 15 Oct 2019 17:22:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/prototype/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 通过给出一个原型对象来知名所有创建的对象的类型，然后用复制这</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 构建模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/builder/</link>
      <pubDate>Tue, 15 Oct 2019 17:06:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/builder/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 建造模式是对象的创建模式。建造模式可以将一个产品的内部表象(</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 抽象工厂模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/abstract-factory/</link>
      <pubDate>Tue, 15 Oct 2019 15:43:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/abstract-factory/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 概述 举个生活中常见的例子&amp;ndash;组装电脑。 我们在组装电</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 动态工厂模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/dynamic-factory/</link>
      <pubDate>Tue, 15 Oct 2019 15:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/dynamic-factory/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 工厂方法模式是类的创建模式，又叫多态性工厂模式，他的用意是定</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 静态工厂模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/static-factory/</link>
      <pubDate>Tue, 15 Oct 2019 15:36:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/static-factory/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 简单工厂模式是类的创建型模式，又叫静态工厂方法模式。简单工厂</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建模式 | 单例模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/creation-type/singleton/</link>
      <pubDate>Tue, 15 Oct 2019 15:10:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/creation-type/singleton/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 单例类只能有一个实例 单例类必须自己创建自己的唯一实例 单例类必</description>
    </item>
    
    <item>
      <title>[设计模式 | 行为模式 | 模板模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/behavior-type/templates/</link>
      <pubDate>Tue, 15 Oct 2019 14:59:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/behavior-type/templates/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 概述 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形</description>
    </item>
    
    <item>
      <title>[设计模式 | 行为模式 | 解释器模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/behavior-type/interpreter/</link>
      <pubDate>Tue, 15 Oct 2019 14:28:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/behavior-type/interpreter/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 概述 给定一个语言后,解释器模式可以定义出其文法的一种表示,并</description>
    </item>
    
    <item>
      <title>[设计模式 | 行为模式 |观察者模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/behavior-type/observer/</link>
      <pubDate>Tue, 15 Oct 2019 11:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/behavior-type/observer/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 概述 观察者模式是对象的行为模式，又叫发布-订阅(Publis</description>
    </item>
    
    <item>
      <title>[设计模式 | 行为模式 | 迭代器模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/behavior-type/lterator/</link>
      <pubDate>Tue, 15 Oct 2019 11:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/behavior-type/lterator/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[设计模式 | 行为模式 | 策略模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/behavior-type/strategy/</link>
      <pubDate>Tue, 15 Oct 2019 10:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/behavior-type/strategy/</guid>
      <description>转载自https://www.cnblogs.com/java-my-life/ 概述 策略模式属于对象的行为模式。其用意是针对一组算法，将每一</description>
    </item>
    
  </channel>
</rss>